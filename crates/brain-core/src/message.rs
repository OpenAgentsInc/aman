//! Message types for brain input and output.

/// An attachment included with a message.
#[derive(Debug, Clone, Default)]
pub struct InboundAttachment {
    /// Content type (MIME type), e.g., "image/jpeg", "application/pdf".
    pub content_type: String,

    /// Original filename if available.
    pub filename: Option<String>,

    /// Local file path where signal-cli saved the attachment.
    pub file_path: Option<String>,

    /// Size in bytes.
    pub size: Option<u64>,

    /// Width in pixels (for images/videos).
    pub width: Option<u32>,

    /// Height in pixels (for images/videos).
    pub height: Option<u32>,

    /// Caption text if provided.
    pub caption: Option<String>,
}

impl InboundAttachment {
    /// Check if this is an image attachment.
    pub fn is_image(&self) -> bool {
        self.content_type.starts_with("image/")
    }

    /// Check if this is a video attachment.
    pub fn is_video(&self) -> bool {
        self.content_type.starts_with("video/")
    }

    /// Check if this is an audio attachment.
    pub fn is_audio(&self) -> bool {
        self.content_type.starts_with("audio/")
    }
}

/// An incoming message to be processed by the brain.
#[derive(Debug, Clone)]
pub struct InboundMessage {
    /// The sender's identifier (phone number in E.164 format).
    pub sender: String,

    /// The message text content.
    pub text: String,

    /// Unix timestamp in milliseconds when the message was sent.
    pub timestamp: u64,

    /// Group ID if this is a group message, None for direct messages.
    pub group_id: Option<String>,

    /// Attachments included with the message.
    pub attachments: Vec<InboundAttachment>,
}

/// An outgoing message generated by the brain.
#[derive(Debug, Clone)]
pub struct OutboundMessage {
    /// The recipient's identifier (phone number or group ID).
    pub recipient: String,

    /// The response text content.
    pub text: String,

    /// Whether this is a group message.
    pub is_group: bool,
}

impl InboundMessage {
    /// Create a new direct message.
    pub fn direct(sender: impl Into<String>, text: impl Into<String>, timestamp: u64) -> Self {
        Self {
            sender: sender.into(),
            text: text.into(),
            timestamp,
            group_id: None,
            attachments: Vec::new(),
        }
    }

    /// Create a new group message.
    pub fn group(
        sender: impl Into<String>,
        text: impl Into<String>,
        timestamp: u64,
        group_id: impl Into<String>,
    ) -> Self {
        Self {
            sender: sender.into(),
            text: text.into(),
            timestamp,
            group_id: Some(group_id.into()),
            attachments: Vec::new(),
        }
    }

    /// Check if this message has any attachments.
    pub fn has_attachments(&self) -> bool {
        !self.attachments.is_empty()
    }

    /// Check if this message has any image attachments.
    pub fn has_images(&self) -> bool {
        self.attachments.iter().any(|a| a.is_image())
    }
}

impl OutboundMessage {
    /// Create a reply to an inbound message.
    pub fn reply_to(inbound: &InboundMessage, text: impl Into<String>) -> Self {
        if let Some(group_id) = &inbound.group_id {
            Self {
                recipient: group_id.clone(),
                text: text.into(),
                is_group: true,
            }
        } else {
            Self {
                recipient: inbound.sender.clone(),
                text: text.into(),
                is_group: false,
            }
        }
    }

    /// Create a direct message to a recipient.
    pub fn direct(recipient: impl Into<String>, text: impl Into<String>) -> Self {
        Self {
            recipient: recipient.into(),
            text: text.into(),
            is_group: false,
        }
    }
}
