//! Message types for brain input and output.

use serde::{Deserialize, Serialize};

/// An attachment included with a message.
#[derive(Debug, Clone, Default)]
pub struct InboundAttachment {
    /// Content type (MIME type), e.g., "image/jpeg", "application/pdf".
    pub content_type: String,

    /// Original filename if available.
    pub filename: Option<String>,

    /// Local file path where signal-cli saved the attachment.
    pub file_path: Option<String>,

    /// Size in bytes.
    pub size: Option<u64>,

    /// Width in pixels (for images/videos).
    pub width: Option<u32>,

    /// Height in pixels (for images/videos).
    pub height: Option<u32>,

    /// Caption text if provided.
    pub caption: Option<String>,
}

impl InboundAttachment {
    /// Check if this is an image attachment.
    pub fn is_image(&self) -> bool {
        self.content_type.starts_with("image/")
    }

    /// Check if this is a video attachment.
    pub fn is_video(&self) -> bool {
        self.content_type.starts_with("video/")
    }

    /// Check if this is an audio attachment.
    pub fn is_audio(&self) -> bool {
        self.content_type.starts_with("audio/")
    }
}

/// Sensitivity level hint for a request.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum Sensitivity {
    /// Sensitive content - use privacy-preserving mode.
    /// Examples: health, finances, legal, personal info.
    Sensitive,

    /// Insensitive content - can use fast mode.
    /// Examples: weather, news, sports, general knowledge, coding.
    #[default]
    Insensitive,

    /// Uncertain - could go either way.
    Uncertain,
}

impl Sensitivity {
    /// Check if this sensitivity level should use privacy-preserving mode.
    pub fn prefers_maple(&self) -> bool {
        matches!(self, Sensitivity::Sensitive | Sensitivity::Uncertain)
    }

    /// Check if this sensitivity level can use fast mode.
    pub fn allows_grok(&self) -> bool {
        matches!(self, Sensitivity::Insensitive)
    }
}

/// Task hint for model selection.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum TaskHint {
    /// General conversation and questions (default).
    #[default]
    General,

    /// Programming and technical development tasks.
    Coding,

    /// Mathematical and analytical reasoning.
    Math,

    /// Creative writing and content generation.
    Creative,

    /// Non-English or translation tasks.
    Multilingual,

    /// Simple queries needing fast responses.
    Quick,

    /// Image/vision analysis tasks.
    Vision,
}

/// Routing metadata attached to an inbound message.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct RoutingInfo {
    /// Sensitivity hint from the router, if available.
    pub sensitivity: Option<Sensitivity>,
    /// Task hint for model selection, if available.
    pub task_hint: Option<TaskHint>,
    /// Model override for this request.
    pub model_override: Option<String>,
    /// Router prompt fingerprint (hash) for reproducibility.
    pub router_prompt_hash: Option<String>,
    /// System prompt fingerprint (hash) for reproducibility.
    pub system_prompt_hash: Option<String>,
}

/// An incoming message to be processed by the brain.
#[derive(Debug, Clone)]
pub struct InboundMessage {
    /// The sender's identifier (phone number in E.164 format).
    pub sender: String,

    /// The message text content.
    pub text: String,

    /// Unix timestamp in milliseconds when the message was sent.
    pub timestamp: u64,

    /// Group ID if this is a group message, None for direct messages.
    pub group_id: Option<String>,

    /// Attachments included with the message.
    pub attachments: Vec<InboundAttachment>,

    /// Optional routing metadata for this request.
    pub routing: Option<RoutingInfo>,
}

/// An outgoing message generated by the brain.
#[derive(Debug, Clone)]
pub struct OutboundMessage {
    /// The recipient's identifier (phone number or group ID).
    pub recipient: String,

    /// The response text content.
    pub text: String,

    /// Whether this is a group message.
    pub is_group: bool,
}

impl InboundMessage {
    /// Create a new direct message.
    pub fn direct(sender: impl Into<String>, text: impl Into<String>, timestamp: u64) -> Self {
        Self {
            sender: sender.into(),
            text: text.into(),
            timestamp,
            group_id: None,
            attachments: Vec::new(),
            routing: None,
        }
    }

    /// Create a new group message.
    pub fn group(
        sender: impl Into<String>,
        text: impl Into<String>,
        timestamp: u64,
        group_id: impl Into<String>,
    ) -> Self {
        Self {
            sender: sender.into(),
            text: text.into(),
            timestamp,
            group_id: Some(group_id.into()),
            attachments: Vec::new(),
            routing: None,
        }
    }

    /// Check if this message has any attachments.
    pub fn has_attachments(&self) -> bool {
        !self.attachments.is_empty()
    }

    /// Check if this message has any image attachments.
    pub fn has_images(&self) -> bool {
        self.attachments.iter().any(|a| a.is_image())
    }

    /// Build a stable history key for this message.
    ///
    /// Group messages are prefixed to avoid collisions with direct senders.
    pub fn history_key(&self) -> String {
        self.group_id
            .as_ref()
            .map(|g| format!("group:{}", g))
            .unwrap_or_else(|| self.sender.clone())
    }
}

impl OutboundMessage {
    /// Create a reply to an inbound message.
    pub fn reply_to(inbound: &InboundMessage, text: impl Into<String>) -> Self {
        if let Some(group_id) = &inbound.group_id {
            Self {
                recipient: group_id.clone(),
                text: text.into(),
                is_group: true,
            }
        } else {
            Self {
                recipient: inbound.sender.clone(),
                text: text.into(),
                is_group: false,
            }
        }
    }

    /// Create a direct message to a recipient.
    pub fn direct(recipient: impl Into<String>, text: impl Into<String>) -> Self {
        Self {
            recipient: recipient.into(),
            text: text.into(),
            is_group: false,
        }
    }
}
